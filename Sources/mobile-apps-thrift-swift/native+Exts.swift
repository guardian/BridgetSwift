/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: AdSlot, rhs: AdSlot) -> Bool {
  return
    (lhs.x == rhs.x) &&
    (lhs.y == rhs.y) &&
    (lhs.height == rhs.height)
}

extension AdSlot : CustomStringConvertible {

  public var description : String {
    var desc = "AdSlot("
    desc += "x=\(String(describing: self.x)), "
    desc += "y=\(String(describing: self.y)), "
    desc += "height=\(String(describing: self.height))"
    return desc
  }

}

extension AdSlot : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (x?.hashValue ?? 0)
    result = prime &* result &+ (y?.hashValue ?? 0)
    result = prime &* result &+ (height?.hashValue ?? 0)
    return result
  }

}

extension AdSlot : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["x": 1, "y": 2, "height": 3, ]
  }

  public static var structName: String { return "AdSlot" }

  public static func read(from proto: TProtocol) throws -> AdSlot {
    _ = try proto.readStructBegin()
    var x: Int32?
    var y: Int32?
    var height: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             x = try Int32.read(from: proto)
        case (2, .i32):             y = try Int32.read(from: proto)
        case (3, .i32):             height = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AdSlot(x: x, y: y, height: height)
  }

}



fileprivate final class Native_insertAdverts_args {

  fileprivate var adSlots: TList<AdSlot>


  fileprivate init(adSlots: TList<AdSlot>) {
    self.adSlots = adSlots
  }

}

fileprivate func ==(lhs: Native_insertAdverts_args, rhs: Native_insertAdverts_args) -> Bool {
  return
    (lhs.adSlots == rhs.adSlots)
}

extension Native_insertAdverts_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (adSlots.hashValue)
    return result
  }

}

extension Native_insertAdverts_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["adSlots": 1, ]
  }

  fileprivate static var structName: String { return "Native_insertAdverts_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Native_insertAdverts_args {
    _ = try proto.readStructBegin()
    var adSlots: TList<AdSlot>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            adSlots = try TList<AdSlot>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(adSlots, named: "adSlots")

    return Native_insertAdverts_args(adSlots: adSlots)
  }

}



fileprivate final class Native_insertAdverts_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Native_insertAdverts_result, rhs: Native_insertAdverts_result) -> Bool {
  return true
}

extension Native_insertAdverts_result : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension Native_insertAdverts_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Native_insertAdverts_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Native_insertAdverts_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Native_insertAdverts_result()
  }

}



fileprivate final class Native_webviewVersionNumber_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Native_webviewVersionNumber_args, rhs: Native_webviewVersionNumber_args) -> Bool {
  return true
}

extension Native_webviewVersionNumber_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension Native_webviewVersionNumber_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Native_webviewVersionNumber_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Native_webviewVersionNumber_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Native_webviewVersionNumber_args()
  }

}



fileprivate final class Native_webviewVersionNumber_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Native_webviewVersionNumber_result, rhs: Native_webviewVersionNumber_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Native_webviewVersionNumber_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    return result
  }

}

extension Native_webviewVersionNumber_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Native_webviewVersionNumber_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Native_webviewVersionNumber_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Native_webviewVersionNumber_result(success: success)
  }

}



fileprivate final class Native_test_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Native_test_args, rhs: Native_test_args) -> Bool {
  return true
}

extension Native_test_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension Native_test_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Native_test_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Native_test_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Native_test_args()
  }

}



fileprivate final class Native_test_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Native_test_result, rhs: Native_test_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Native_test_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    return result
  }

}

extension Native_test_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Native_test_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Native_test_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Native_test_result(success: success)
  }

}



extension NativeClient : Native {

  private func send_insertAdverts(adSlots: TList<AdSlot>) throws {
    try outProtocol.writeMessageBegin(name: "insertAdverts", type: .call, sequenceID: 0)
    let args = Native_insertAdverts_args(adSlots: adSlots)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_insertAdverts() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Native_insertAdverts_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func insertAdverts(adSlots: TList<AdSlot>) throws {
    try send_insertAdverts(adSlots: adSlots)
    try outProtocol.transport.flush()
    try recv_insertAdverts()
  }

  private func send_webviewVersionNumber() throws {
    try outProtocol.writeMessageBegin(name: "webviewVersionNumber", type: .call, sequenceID: 0)
    let args = Native_webviewVersionNumber_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_webviewVersionNumber() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Native_webviewVersionNumber_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "webviewVersionNumber"))
  }

  public func webviewVersionNumber() throws -> Int32 {
    try send_webviewVersionNumber()
    try outProtocol.transport.flush()
    return try recv_webviewVersionNumber()
  }

  private func send_test() throws {
    try outProtocol.writeMessageBegin(name: "test", type: .call, sequenceID: 0)
    let args = Native_test_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_test() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Native_test_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "test"))
  }

  public func test() throws -> Int32 {
    try send_test()
    try outProtocol.transport.flush()
    return try recv_test()
  }

}

extension NativeProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["insertAdverts"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Native_insertAdverts_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Native_insertAdverts_result()
      do {
        try handler.insertAdverts(adSlots: args.adSlots)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "insertAdverts", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["webviewVersionNumber"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Native_webviewVersionNumber_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Native_webviewVersionNumber_result()
      do {
        result.success = try handler.webviewVersionNumber()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "webviewVersionNumber", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["test"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Native_test_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Native_test_result()
      do {
        result.success = try handler.test()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "test", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = NativeProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

