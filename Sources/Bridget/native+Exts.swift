/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: AdSlot, rhs: AdSlot) -> Bool {
  return
    (lhs.x == rhs.x) &&
    (lhs.y == rhs.y) &&
    (lhs.height == rhs.height) &&
    (lhs.width == rhs.width)
}

extension AdSlot : CustomStringConvertible {

  public var description : String {
    var desc = "AdSlot("
    desc += "x=\(String(describing: self.x)), "
    desc += "y=\(String(describing: self.y)), "
    desc += "height=\(String(describing: self.height)), "
    desc += "width=\(String(describing: self.width))"
    return desc
  }

}

extension AdSlot : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(x)
    hasher.combine(y)
    hasher.combine(height)
    hasher.combine(width)
  }

}

extension AdSlot : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["x": 1, "y": 2, "height": 3, "width": 4, ]
  }

  public static var structName: String { return "AdSlot" }

  public static func read(from proto: TProtocol) throws -> AdSlot {
    _ = try proto.readStructBegin()
    var x: Int32!
    var y: Int32!
    var height: Int32?
    var width: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             x = try Int32.read(from: proto)
        case (2, .i32):             y = try Int32.read(from: proto)
        case (3, .i32):             height = try Int32.read(from: proto)
        case (4, .i32):             width = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(x, named: "x")
    try proto.validateValue(y, named: "y")

    return AdSlot(x: x, y: y, height: height, width: width)
  }

}



public func ==(lhs: Topic, rhs: Topic) -> Bool {
  return
    (lhs.id == rhs.id)
}

extension Topic : CustomStringConvertible {

  public var description : String {
    var desc = "Topic("
    desc += "id=\(String(describing: self.id))"
    return desc
  }

}

extension Topic : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(id)
  }

}

extension Topic : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, ]
  }

  public static var structName: String { return "Topic" }

  public static func read(from proto: TProtocol) throws -> Topic {
    _ = try proto.readStructBegin()
    var id: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           id = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")

    return Topic(id: id)
  }

}



public func ==(lhs: Image, rhs: Image) -> Bool {
  return
    (lhs.url == rhs.url) &&
    (lhs.caption == rhs.caption) &&
    (lhs.credit == rhs.credit)
}

extension Image : CustomStringConvertible {

  public var description : String {
    var desc = "Image("
    desc += "url=\(String(describing: self.url)), "
    desc += "caption=\(String(describing: self.caption)), "
    desc += "credit=\(String(describing: self.credit))"
    return desc
  }

}

extension Image : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(url)
    hasher.combine(caption)
    hasher.combine(credit)
  }

}

extension Image : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["url": 1, "caption": 2, "credit": 3, ]
  }

  public static var structName: String { return "Image" }

  public static func read(from proto: TProtocol) throws -> Image {
    _ = try proto.readStructBegin()
    var url: String!
    var caption: String?
    var credit: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           url = try String.read(from: proto)
        case (2, .string):           caption = try String.read(from: proto)
        case (3, .string):           credit = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(url, named: "url")

    return Image(url: url, caption: caption, credit: credit)
  }

}



public func ==(lhs: Epic, rhs: Epic) -> Bool {
  return
    (lhs.title == rhs.title) &&
    (lhs.body == rhs.body) &&
    (lhs.firstButton == rhs.firstButton) &&
    (lhs.secondButton == rhs.secondButton)
}

extension Epic : CustomStringConvertible {

  public var description : String {
    var desc = "Epic("
    desc += "title=\(String(describing: self.title)), "
    desc += "body=\(String(describing: self.body)), "
    desc += "firstButton=\(String(describing: self.firstButton)), "
    desc += "secondButton=\(String(describing: self.secondButton))"
    return desc
  }

}

extension Epic : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(title)
    hasher.combine(body)
    hasher.combine(firstButton)
    hasher.combine(secondButton)
  }

}

extension Epic : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["title": 1, "body": 2, "firstButton": 3, "secondButton": 4, ]
  }

  public static var structName: String { return "Epic" }

  public static func read(from proto: TProtocol) throws -> Epic {
    _ = try proto.readStructBegin()
    var title: String!
    var body: String!
    var firstButton: String!
    var secondButton: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           title = try String.read(from: proto)
        case (2, .string):           body = try String.read(from: proto)
        case (3, .string):           firstButton = try String.read(from: proto)
        case (4, .string):           secondButton = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(title, named: "title")
    try proto.validateValue(body, named: "body")
    try proto.validateValue(firstButton, named: "firstButton")

    return Epic(title: title, body: body, firstButton: firstButton, secondButton: secondButton)
  }

}



public func ==(lhs: MaybeEpic, rhs: MaybeEpic) -> Bool {
  return
    (lhs.epic == rhs.epic)
}

extension MaybeEpic : CustomStringConvertible {

  public var description : String {
    var desc = "MaybeEpic("
    desc += "epic=\(String(describing: self.epic))"
    return desc
  }

}

extension MaybeEpic : Hashable {

  public func hash(into hasher: inout Hasher) {
    hasher.combine(epic)
  }

}

extension MaybeEpic : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["epic": 1, ]
  }

  public static var structName: String { return "MaybeEpic" }

  public static func read(from proto: TProtocol) throws -> MaybeEpic {
    _ = try proto.readStructBegin()
    var epic: Epic?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           epic = try Epic.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return MaybeEpic(epic: epic)
  }

}



fileprivate final class Environment_nativeThriftPackageVersion_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Environment_nativeThriftPackageVersion_args, rhs: Environment_nativeThriftPackageVersion_args) -> Bool {
  return true
}

extension Environment_nativeThriftPackageVersion_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Environment_nativeThriftPackageVersion_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Environment_nativeThriftPackageVersion_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Environment_nativeThriftPackageVersion_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Environment_nativeThriftPackageVersion_args()
  }

}



fileprivate final class Environment_nativeThriftPackageVersion_result {

  fileprivate var success: Int32?


  fileprivate init() { }
  fileprivate init(success: Int32?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Environment_nativeThriftPackageVersion_result, rhs: Environment_nativeThriftPackageVersion_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Environment_nativeThriftPackageVersion_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Environment_nativeThriftPackageVersion_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Environment_nativeThriftPackageVersion_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Environment_nativeThriftPackageVersion_result {
    _ = try proto.readStructBegin()
    var success: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Environment_nativeThriftPackageVersion_result(success: success)
  }

}



extension EnvironmentClient : Environment {

  private func send_nativeThriftPackageVersion() throws {
    try outProtocol.writeMessageBegin(name: "nativeThriftPackageVersion", type: .call, sequenceID: 0)
    let args = Environment_nativeThriftPackageVersion_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_nativeThriftPackageVersion() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try Environment_nativeThriftPackageVersion_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "nativeThriftPackageVersion"))
  }

  public func nativeThriftPackageVersion() throws -> Int32 {
    try send_nativeThriftPackageVersion()
    try outProtocol.transport.flush()
    return try recv_nativeThriftPackageVersion()
  }

}

extension EnvironmentProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["nativeThriftPackageVersion"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Environment_nativeThriftPackageVersion_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Environment_nativeThriftPackageVersion_result()
      do {
        result.success = try handler.nativeThriftPackageVersion()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "nativeThriftPackageVersion", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = EnvironmentProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

extension EnvironmentProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["nativeThriftPackageVersion"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Environment_nativeThriftPackageVersion_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.nativeThriftPackageVersion(completion: { asyncResult in
        var result = Environment_nativeThriftPackageVersion_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "nativeThriftPackageVersion", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "nativeThriftPackageVersion", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "nativeThriftPackageVersion", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = EnvironmentProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class Commercial_insertAdverts_args {

  fileprivate var adSlots: TList<AdSlot>


  fileprivate init(adSlots: TList<AdSlot>) {
    self.adSlots = adSlots
  }

}

fileprivate func ==(lhs: Commercial_insertAdverts_args, rhs: Commercial_insertAdverts_args) -> Bool {
  return
    (lhs.adSlots == rhs.adSlots)
}

extension Commercial_insertAdverts_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(adSlots)
  }

}

extension Commercial_insertAdverts_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["adSlots": 1, ]
  }

  fileprivate static var structName: String { return "Commercial_insertAdverts_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Commercial_insertAdverts_args {
    _ = try proto.readStructBegin()
    var adSlots: TList<AdSlot>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            adSlots = try TList<AdSlot>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(adSlots, named: "adSlots")

    return Commercial_insertAdverts_args(adSlots: adSlots)
  }

}



fileprivate final class Commercial_insertAdverts_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Commercial_insertAdverts_result, rhs: Commercial_insertAdverts_result) -> Bool {
  return true
}

extension Commercial_insertAdverts_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Commercial_insertAdverts_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Commercial_insertAdverts_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Commercial_insertAdverts_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Commercial_insertAdverts_result()
  }

}



fileprivate final class Commercial_updateAdverts_args {

  fileprivate var adSlots: TList<AdSlot>


  fileprivate init(adSlots: TList<AdSlot>) {
    self.adSlots = adSlots
  }

}

fileprivate func ==(lhs: Commercial_updateAdverts_args, rhs: Commercial_updateAdverts_args) -> Bool {
  return
    (lhs.adSlots == rhs.adSlots)
}

extension Commercial_updateAdverts_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(adSlots)
  }

}

extension Commercial_updateAdverts_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["adSlots": 1, ]
  }

  fileprivate static var structName: String { return "Commercial_updateAdverts_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Commercial_updateAdverts_args {
    _ = try proto.readStructBegin()
    var adSlots: TList<AdSlot>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            adSlots = try TList<AdSlot>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(adSlots, named: "adSlots")

    return Commercial_updateAdverts_args(adSlots: adSlots)
  }

}



fileprivate final class Commercial_updateAdverts_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Commercial_updateAdverts_result, rhs: Commercial_updateAdverts_result) -> Bool {
  return true
}

extension Commercial_updateAdverts_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Commercial_updateAdverts_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Commercial_updateAdverts_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Commercial_updateAdverts_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Commercial_updateAdverts_result()
  }

}



extension CommercialClient : Commercial {

  private func send_insertAdverts(adSlots: TList<AdSlot>) throws {
    try outProtocol.writeMessageBegin(name: "insertAdverts", type: .call, sequenceID: 0)
    let args = Commercial_insertAdverts_args(adSlots: adSlots)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_insertAdverts() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Commercial_insertAdverts_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func insertAdverts(adSlots: TList<AdSlot>) throws {
    try send_insertAdverts(adSlots: adSlots)
    try outProtocol.transport.flush()
    try recv_insertAdverts()
  }

  private func send_updateAdverts(adSlots: TList<AdSlot>) throws {
    try outProtocol.writeMessageBegin(name: "updateAdverts", type: .call, sequenceID: 0)
    let args = Commercial_updateAdverts_args(adSlots: adSlots)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_updateAdverts() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Commercial_updateAdverts_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func updateAdverts(adSlots: TList<AdSlot>) throws {
    try send_updateAdverts(adSlots: adSlots)
    try outProtocol.transport.flush()
    try recv_updateAdverts()
  }

}

extension CommercialProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["insertAdverts"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Commercial_insertAdverts_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Commercial_insertAdverts_result()
      do {
        try handler.insertAdverts(adSlots: args.adSlots)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "insertAdverts", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["updateAdverts"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Commercial_updateAdverts_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Commercial_updateAdverts_result()
      do {
        try handler.updateAdverts(adSlots: args.adSlots)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "updateAdverts", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = CommercialProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

extension CommercialProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["insertAdverts"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Commercial_insertAdverts_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.insertAdverts(adSlots: args.adSlots, completion: { asyncResult in
        var result = Commercial_insertAdverts_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "insertAdverts", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "insertAdverts", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "insertAdverts", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["updateAdverts"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Commercial_updateAdverts_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.updateAdverts(adSlots: args.adSlots, completion: { asyncResult in
        var result = Commercial_updateAdverts_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "updateAdverts", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "updateAdverts", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "updateAdverts", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = CommercialProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class Acquistions_launchFrictionScreen_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Acquistions_launchFrictionScreen_args, rhs: Acquistions_launchFrictionScreen_args) -> Bool {
  return true
}

extension Acquistions_launchFrictionScreen_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Acquistions_launchFrictionScreen_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Acquistions_launchFrictionScreen_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Acquistions_launchFrictionScreen_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Acquistions_launchFrictionScreen_args()
  }

}



fileprivate final class Acquistions_launchFrictionScreen_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Acquistions_launchFrictionScreen_result, rhs: Acquistions_launchFrictionScreen_result) -> Bool {
  return true
}

extension Acquistions_launchFrictionScreen_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Acquistions_launchFrictionScreen_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Acquistions_launchFrictionScreen_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Acquistions_launchFrictionScreen_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Acquistions_launchFrictionScreen_result()
  }

}



fileprivate final class Acquistions_getEpics_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Acquistions_getEpics_args, rhs: Acquistions_getEpics_args) -> Bool {
  return true
}

extension Acquistions_getEpics_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Acquistions_getEpics_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Acquistions_getEpics_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Acquistions_getEpics_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Acquistions_getEpics_args()
  }

}



fileprivate final class Acquistions_getEpics_result {

  fileprivate var success: MaybeEpic?


  fileprivate init() { }
  fileprivate init(success: MaybeEpic?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Acquistions_getEpics_result, rhs: Acquistions_getEpics_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Acquistions_getEpics_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Acquistions_getEpics_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Acquistions_getEpics_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Acquistions_getEpics_result {
    _ = try proto.readStructBegin()
    var success: MaybeEpic?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try MaybeEpic.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Acquistions_getEpics_result(success: success)
  }

}



fileprivate final class Acquistions_epicSeen_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: Acquistions_epicSeen_args, rhs: Acquistions_epicSeen_args) -> Bool {
  return true
}

extension Acquistions_epicSeen_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Acquistions_epicSeen_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Acquistions_epicSeen_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Acquistions_epicSeen_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Acquistions_epicSeen_args()
  }

}



fileprivate final class Acquistions_epicSeen_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Acquistions_epicSeen_result, rhs: Acquistions_epicSeen_result) -> Bool {
  return true
}

extension Acquistions_epicSeen_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Acquistions_epicSeen_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Acquistions_epicSeen_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Acquistions_epicSeen_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Acquistions_epicSeen_result()
  }

}



extension AcquistionsClient : Acquistions {

  private func send_launchFrictionScreen() throws {
    try outProtocol.writeMessageBegin(name: "launchFrictionScreen", type: .call, sequenceID: 0)
    let args = Acquistions_launchFrictionScreen_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_launchFrictionScreen() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Acquistions_launchFrictionScreen_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func launchFrictionScreen() throws {
    try send_launchFrictionScreen()
    try outProtocol.transport.flush()
    try recv_launchFrictionScreen()
  }

  private func send_getEpics() throws {
    try outProtocol.writeMessageBegin(name: "getEpics", type: .call, sequenceID: 0)
    let args = Acquistions_getEpics_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getEpics() throws -> MaybeEpic {
    try inProtocol.readResultMessageBegin() 
    let result = try Acquistions_getEpics_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "getEpics"))
  }

  public func getEpics() throws -> MaybeEpic {
    try send_getEpics()
    try outProtocol.transport.flush()
    return try recv_getEpics()
  }

  private func send_epicSeen() throws {
    try outProtocol.writeMessageBegin(name: "epicSeen", type: .call, sequenceID: 0)
    let args = Acquistions_epicSeen_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_epicSeen() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Acquistions_epicSeen_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func epicSeen() throws {
    try send_epicSeen()
    try outProtocol.transport.flush()
    try recv_epicSeen()
  }

}

extension AcquistionsProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["launchFrictionScreen"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Acquistions_launchFrictionScreen_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Acquistions_launchFrictionScreen_result()
      do {
        try handler.launchFrictionScreen()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "launchFrictionScreen", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getEpics"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Acquistions_getEpics_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Acquistions_getEpics_result()
      do {
        result.success = try handler.getEpics()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getEpics", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["epicSeen"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Acquistions_epicSeen_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Acquistions_epicSeen_result()
      do {
        try handler.epicSeen()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "epicSeen", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = AcquistionsProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

extension AcquistionsProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["launchFrictionScreen"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Acquistions_launchFrictionScreen_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.launchFrictionScreen(completion: { asyncResult in
        var result = Acquistions_launchFrictionScreen_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "launchFrictionScreen", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "launchFrictionScreen", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "launchFrictionScreen", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["getEpics"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Acquistions_getEpics_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.getEpics(completion: { asyncResult in
        var result = Acquistions_getEpics_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "getEpics", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "getEpics", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "getEpics", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["epicSeen"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Acquistions_epicSeen_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.epicSeen(completion: { asyncResult in
        var result = Acquistions_epicSeen_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "epicSeen", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "epicSeen", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "epicSeen", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = AcquistionsProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class Notifications_follow_args {

  fileprivate var topic: Topic


  fileprivate init(topic: Topic) {
    self.topic = topic
  }

}

fileprivate func ==(lhs: Notifications_follow_args, rhs: Notifications_follow_args) -> Bool {
  return
    (lhs.topic == rhs.topic)
}

extension Notifications_follow_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(topic)
  }

}

extension Notifications_follow_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["topic": 1, ]
  }

  fileprivate static var structName: String { return "Notifications_follow_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Notifications_follow_args {
    _ = try proto.readStructBegin()
    var topic: Topic!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           topic = try Topic.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(topic, named: "topic")

    return Notifications_follow_args(topic: topic)
  }

}



fileprivate final class Notifications_follow_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Notifications_follow_result, rhs: Notifications_follow_result) -> Bool {
  return true
}

extension Notifications_follow_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Notifications_follow_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Notifications_follow_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Notifications_follow_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Notifications_follow_result()
  }

}



fileprivate final class Notifications_unfollow_args {

  fileprivate var topic: Topic


  fileprivate init(topic: Topic) {
    self.topic = topic
  }

}

fileprivate func ==(lhs: Notifications_unfollow_args, rhs: Notifications_unfollow_args) -> Bool {
  return
    (lhs.topic == rhs.topic)
}

extension Notifications_unfollow_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(topic)
  }

}

extension Notifications_unfollow_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["topic": 1, ]
  }

  fileprivate static var structName: String { return "Notifications_unfollow_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Notifications_unfollow_args {
    _ = try proto.readStructBegin()
    var topic: Topic!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           topic = try Topic.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(topic, named: "topic")

    return Notifications_unfollow_args(topic: topic)
  }

}



fileprivate final class Notifications_unfollow_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Notifications_unfollow_result, rhs: Notifications_unfollow_result) -> Bool {
  return true
}

extension Notifications_unfollow_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Notifications_unfollow_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Notifications_unfollow_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Notifications_unfollow_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Notifications_unfollow_result()
  }

}



fileprivate final class Notifications_isFollowing_args {

  fileprivate var topic: Topic


  fileprivate init(topic: Topic) {
    self.topic = topic
  }

}

fileprivate func ==(lhs: Notifications_isFollowing_args, rhs: Notifications_isFollowing_args) -> Bool {
  return
    (lhs.topic == rhs.topic)
}

extension Notifications_isFollowing_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(topic)
  }

}

extension Notifications_isFollowing_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["topic": 1, ]
  }

  fileprivate static var structName: String { return "Notifications_isFollowing_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Notifications_isFollowing_args {
    _ = try proto.readStructBegin()
    var topic: Topic!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           topic = try Topic.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(topic, named: "topic")

    return Notifications_isFollowing_args(topic: topic)
  }

}



fileprivate final class Notifications_isFollowing_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: Notifications_isFollowing_result, rhs: Notifications_isFollowing_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension Notifications_isFollowing_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension Notifications_isFollowing_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "Notifications_isFollowing_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Notifications_isFollowing_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Notifications_isFollowing_result(success: success)
  }

}



extension NotificationsClient : Notifications {

  private func send_follow(topic: Topic) throws {
    try outProtocol.writeMessageBegin(name: "follow", type: .call, sequenceID: 0)
    let args = Notifications_follow_args(topic: topic)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_follow() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Notifications_follow_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func follow(topic: Topic) throws {
    try send_follow(topic: topic)
    try outProtocol.transport.flush()
    try recv_follow()
  }

  private func send_unfollow(topic: Topic) throws {
    try outProtocol.writeMessageBegin(name: "unfollow", type: .call, sequenceID: 0)
    let args = Notifications_unfollow_args(topic: topic)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_unfollow() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Notifications_unfollow_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func unfollow(topic: Topic) throws {
    try send_unfollow(topic: topic)
    try outProtocol.transport.flush()
    try recv_unfollow()
  }

  private func send_isFollowing(topic: Topic) throws {
    try outProtocol.writeMessageBegin(name: "isFollowing", type: .call, sequenceID: 0)
    let args = Notifications_isFollowing_args(topic: topic)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_isFollowing() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try Notifications_isFollowing_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "isFollowing"))
  }

  public func isFollowing(topic: Topic) throws -> Bool {
    try send_isFollowing(topic: topic)
    try outProtocol.transport.flush()
    return try recv_isFollowing()
  }

}

extension NotificationsProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["follow"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Notifications_follow_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Notifications_follow_result()
      do {
        try handler.follow(topic: args.topic)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "follow", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["unfollow"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Notifications_unfollow_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Notifications_unfollow_result()
      do {
        try handler.unfollow(topic: args.topic)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "unfollow", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["isFollowing"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Notifications_isFollowing_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Notifications_isFollowing_result()
      do {
        result.success = try handler.isFollowing(topic: args.topic)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "isFollowing", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = NotificationsProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

extension NotificationsProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["follow"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Notifications_follow_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.follow(topic: args.topic, completion: { asyncResult in
        var result = Notifications_follow_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "follow", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "follow", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "follow", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["unfollow"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Notifications_unfollow_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.unfollow(topic: args.topic, completion: { asyncResult in
        var result = Notifications_unfollow_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "unfollow", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "unfollow", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "unfollow", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    processorHandlers["isFollowing"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Notifications_isFollowing_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.isFollowing(topic: args.topic, completion: { asyncResult in
        var result = Notifications_isFollowing_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "isFollowing", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "isFollowing", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "isFollowing", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = NotificationsProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class User_isPremium_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: User_isPremium_args, rhs: User_isPremium_args) -> Bool {
  return true
}

extension User_isPremium_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension User_isPremium_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "User_isPremium_args" }

  fileprivate static func read(from proto: TProtocol) throws -> User_isPremium_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return User_isPremium_args()
  }

}



fileprivate final class User_isPremium_result {

  fileprivate var success: Bool?


  fileprivate init() { }
  fileprivate init(success: Bool?) {
    self.success = success
  }

}

fileprivate func ==(lhs: User_isPremium_result, rhs: User_isPremium_result) -> Bool {
  return
    (lhs.success == rhs.success)
}

extension User_isPremium_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(success)
  }

}

extension User_isPremium_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, ]
  }

  fileprivate static var structName: String { return "User_isPremium_result" }

  fileprivate static func read(from proto: TProtocol) throws -> User_isPremium_result {
    _ = try proto.readStructBegin()
    var success: Bool?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return User_isPremium_result(success: success)
  }

}



extension UserClient : User {

  private func send_isPremium() throws {
    try outProtocol.writeMessageBegin(name: "isPremium", type: .call, sequenceID: 0)
    let args = User_isPremium_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_isPremium() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try User_isPremium_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    throw TApplicationError(error: .missingResult(methodName: "isPremium"))
  }

  public func isPremium() throws -> Bool {
    try send_isPremium()
    try outProtocol.transport.flush()
    return try recv_isPremium()
  }

}

extension UserProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["isPremium"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try User_isPremium_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = User_isPremium_result()
      do {
        result.success = try handler.isPremium()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "isPremium", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = UserProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

extension UserProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["isPremium"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try User_isPremium_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.isPremium(completion: { asyncResult in
        var result = User_isPremium_result()
        do {
          try result.success = asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "isPremium", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "isPremium", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "isPremium", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = UserProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

fileprivate final class Gallery_launchSlideshow_args {

  fileprivate var images: TList<Image>

  fileprivate var selectedIndex: Int32


  fileprivate init(images: TList<Image>, selectedIndex: Int32) {
    self.images = images
    self.selectedIndex = selectedIndex
  }

}

fileprivate func ==(lhs: Gallery_launchSlideshow_args, rhs: Gallery_launchSlideshow_args) -> Bool {
  return
    (lhs.images == rhs.images) &&
    (lhs.selectedIndex == rhs.selectedIndex)
}

extension Gallery_launchSlideshow_args : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
    hasher.combine(images)
    hasher.combine(selectedIndex)
  }

}

extension Gallery_launchSlideshow_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["images": 1, "selectedIndex": 2, ]
  }

  fileprivate static var structName: String { return "Gallery_launchSlideshow_args" }

  fileprivate static func read(from proto: TProtocol) throws -> Gallery_launchSlideshow_args {
    _ = try proto.readStructBegin()
    var images: TList<Image>!
    var selectedIndex: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            images = try TList<Image>.read(from: proto)
        case (2, .i32):             selectedIndex = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(images, named: "images")
    try proto.validateValue(selectedIndex, named: "selectedIndex")

    return Gallery_launchSlideshow_args(images: images, selectedIndex: selectedIndex)
  }

}



fileprivate final class Gallery_launchSlideshow_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: Gallery_launchSlideshow_result, rhs: Gallery_launchSlideshow_result) -> Bool {
  return true
}

extension Gallery_launchSlideshow_result : Hashable {

  fileprivate func hash(into hasher: inout Hasher) {
  }

}

extension Gallery_launchSlideshow_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "Gallery_launchSlideshow_result" }

  fileprivate static func read(from proto: TProtocol) throws -> Gallery_launchSlideshow_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return Gallery_launchSlideshow_result()
  }

}



extension GalleryClient : Gallery {

  private func send_launchSlideshow(images: TList<Image>, selectedIndex: Int32) throws {
    try outProtocol.writeMessageBegin(name: "launchSlideshow", type: .call, sequenceID: 0)
    let args = Gallery_launchSlideshow_args(images: images, selectedIndex: selectedIndex)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_launchSlideshow() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try Gallery_launchSlideshow_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func launchSlideshow(images: TList<Image>, selectedIndex: Int32) throws {
    try send_launchSlideshow(images: images, selectedIndex: selectedIndex)
    try outProtocol.transport.flush()
    try recv_launchSlideshow()
  }

}

extension GalleryProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["launchSlideshow"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Gallery_launchSlideshow_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = Gallery_launchSlideshow_result()
      do {
        try handler.launchSlideshow(images: args.images, selectedIndex: args.selectedIndex)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "launchSlideshow", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = GalleryProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

extension GalleryProcessorAsync : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["launchSlideshow"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try Gallery_launchSlideshow_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      handler.launchSlideshow(images: args.images, selectedIndex: args.selectedIndex, completion: { asyncResult in
        var result = Gallery_launchSlideshow_result()
        do {
          try asyncResult.get()
        } catch let error as TApplicationError {
          _ = try? outProtocol.writeException(messageName: "launchSlideshow", sequenceID: sequenceID, ex: error)
          return
        } catch let error {
          _ = try? outProtocol.writeException(messageName: "launchSlideshow", sequenceID: sequenceID, ex: TApplicationError(error: .internalError))
          return
        }
        do {
          try outProtocol.writeMessageBegin(name: "launchSlideshow", type: .reply, sequenceID: sequenceID)
          try result.write(to: outProtocol)
          try outProtocol.writeMessageEnd()
          try outProtocol.transport.flush()
        } catch { }
      })
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = GalleryProcessorAsync.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

